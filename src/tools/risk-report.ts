import { repoCache } from "../index.js";
import { RiskFactor } from "../types.js";

/**
 * Generate a detailed risk assessment report
 */
export async function riskReport(repoPath?: string): Promise<string> {
  const analysis = repoCache.get(repoPath);

  if (!analysis) {
    return `No repository has been analyzed yet. Please run analyze_repo first.`;
  }

  const lines: string[] = [];

  // Header
  lines.push(`â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`);
  lines.push(`â•‘  REPO THERAPIST - Risk Assessment Report                     â•‘`);
  lines.push(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`);

  lines.push(`Repository: **${analysis.name}**`);
  lines.push(`Analyzed: ${new Date(analysis.analyzedAt).toLocaleString()}\n`);

  // Executive Summary
  const highRisks = analysis.risks.filter((r) => r.severity === "high");
  const medRisks = analysis.risks.filter((r) => r.severity === "medium");
  const lowRisks = analysis.risks.filter((r) => r.severity === "low");

  lines.push(`## Executive Summary\n`);

  if (analysis.risks.length === 0) {
    lines.push(`âœ… **No significant risks identified!**\n`);
    lines.push(`The codebase appears to be well-structured and maintained.`);
    lines.push(`Continue following best practices to maintain this healthy state.\n`);
  } else {
    const overallScore = calculateHealthScore(analysis.risks);
    lines.push(`**Overall Health Score: ${overallScore}/100**\n`);
    lines.push(`| Severity | Count |`);
    lines.push(`|----------|-------|`);
    lines.push(`| ðŸ”´ High | ${highRisks.length} |`);
    lines.push(`| ðŸŸ¡ Medium | ${medRisks.length} |`);
    lines.push(`| ðŸŸ¢ Low | ${lowRisks.length} |`);
    lines.push("");
  }

  // High severity risks
  if (highRisks.length > 0) {
    lines.push(`\n## ðŸ”´ High Severity Issues\n`);
    lines.push(`These issues should be addressed as soon as possible.\n`);
    for (const risk of highRisks) {
      lines.push(formatRiskDetail(risk));
    }
  }

  // Medium severity risks
  if (medRisks.length > 0) {
    lines.push(`\n## ðŸŸ¡ Medium Severity Issues\n`);
    lines.push(`Consider addressing these in your next sprint.\n`);
    for (const risk of medRisks) {
      lines.push(formatRiskDetail(risk));
    }
  }

  // Low severity risks
  if (lowRisks.length > 0) {
    lines.push(`\n## ðŸŸ¢ Low Severity Issues\n`);
    lines.push(`Nice-to-fix when you have time.\n`);
    for (const risk of lowRisks) {
      lines.push(formatRiskDetail(risk));
    }
  }

  // Complexity hotspots
  lines.push(`\n## ðŸ“Š Complexity Hotspots\n`);
  lines.push(`Files that may need attention due to size:\n`);

  for (const file of analysis.codeMetrics.largestFiles.slice(0, 5)) {
    const indicator =
      file.lineCount > 1000 ? "ðŸ”´" : file.lineCount > 500 ? "ðŸŸ¡" : "ðŸŸ¢";
    lines.push(`${indicator} **${file.path}**`);
    lines.push(`   ${file.lineCount} lines | ${file.extension}\n`);
  }

  // Churn analysis
  if (analysis.gitMetrics && analysis.gitMetrics.mostChangedFiles.length > 0) {
    lines.push(`\n## ðŸ”„ High-Churn Files\n`);
    lines.push(`Files that change frequently (potential instability indicators):\n`);

    for (const file of analysis.gitMetrics.mostChangedFiles.slice(0, 5)) {
      const churnLevel =
        file.changes > 20 ? "ðŸ”´" : file.changes > 10 ? "ðŸŸ¡" : "ðŸŸ¢";
      lines.push(`${churnLevel} **${file.path}**`);
      lines.push(`   Changed ${file.changes} times in recent history\n`);
    }
  }

  // Recommendations
  lines.push(`\n## ðŸ’¡ Recommendations\n`);

  const recommendations = generateRecommendations(analysis);
  for (let i = 0; i < recommendations.length; i++) {
    lines.push(`${i + 1}. ${recommendations[i]}`);
  }

  // Areas that "scare" us
  lines.push(`\n## ðŸ˜° Areas of Concern\n`);
  lines.push(`*"Which parts of this repo scare you?"*\n`);

  const scaryAreas = identifyScaryAreas(analysis);
  if (scaryAreas.length === 0) {
    lines.push(`Nothing particularly scary found! This repo looks manageable.`);
  } else {
    for (const area of scaryAreas) {
      lines.push(`- ${area}`);
    }
  }

  // Footer
  lines.push(`\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
  lines.push(`Report generated by Repo Therapist`);
  lines.push(`Use ask_repo() to dive deeper into specific concerns.`);

  return lines.join("\n");
}

function formatRiskDetail(risk: RiskFactor): string {
  const lines: string[] = [];
  lines.push(`### ${risk.file || "General"}`);
  lines.push(`**Type:** ${risk.type}`);
  lines.push(`**Issue:** ${risk.description}`);
  lines.push(`**Recommendation:** ${risk.recommendation}\n`);
  return lines.join("\n");
}

function calculateHealthScore(risks: RiskFactor[]): number {
  let score = 100;

  for (const risk of risks) {
    switch (risk.severity) {
      case "high":
        score -= 15;
        break;
      case "medium":
        score -= 5;
        break;
      case "low":
        score -= 2;
        break;
    }
  }

  return Math.max(0, score);
}

function generateRecommendations(analysis: {
  risks: RiskFactor[];
  structure: { hasReadme: boolean; entryPoints: string[] };
  codeMetrics: { largestFiles: { path: string; lineCount: number }[] };
}): string[] {
  const recs: string[] = [];

  // Based on risks
  const hasLargeFiles = analysis.risks.some((r) => r.type === "size");
  const hasChurnFiles = analysis.risks.some((r) => r.type === "churn");
  const hasMissingDocs = analysis.risks.some(
    (r) => r.type === "structure" && r.description.includes("README")
  );

  if (hasLargeFiles) {
    recs.push(
      "**Refactor large files:** Consider breaking down files over 500 lines into smaller, focused modules."
    );
  }

  if (hasChurnFiles) {
    recs.push(
      "**Stabilize high-churn areas:** Files that change frequently may benefit from better abstraction or clearer requirements."
    );
  }

  if (hasMissingDocs) {
    recs.push(
      "**Add documentation:** A README helps new contributors understand the project quickly."
    );
  }

  if (analysis.structure.entryPoints.length === 0) {
    recs.push(
      "**Define clear entry points:** Consider adding a main entry file (e.g., src/index.ts) for better discoverability."
    );
  }

  // General recommendations
  if (recs.length === 0) {
    recs.push("**Keep it up!** The codebase is in good shape.");
    recs.push(
      "**Consider code reviews:** Regular reviews help catch issues early."
    );
  }

  recs.push(
    "**Regular refactoring:** Schedule time to address technical debt before it accumulates."
  );

  return recs;
}

function identifyScaryAreas(analysis: {
  risks: RiskFactor[];
  codeMetrics: { largestFiles: { path: string; lineCount: number }[] };
  gitMetrics: { mostChangedFiles: { path: string; changes: number }[] } | null;
}): string[] {
  const scary: string[] = [];

  // Very large files
  const veryLargeFiles = analysis.codeMetrics.largestFiles.filter(
    (f) => f.lineCount > 1000
  );
  for (const file of veryLargeFiles.slice(0, 3)) {
    scary.push(
      `**${file.path}** (${file.lineCount} lines) - This file is massive and likely hard to maintain or understand fully.`
    );
  }

  // High churn + large = scary combo
  if (analysis.gitMetrics) {
    const highChurn = analysis.gitMetrics.mostChangedFiles.filter(
      (f) => f.changes > 15
    );
    const largeFileNames = analysis.codeMetrics.largestFiles.map((f) => f.path);

    for (const file of highChurn) {
      if (largeFileNames.includes(file.path)) {
        scary.push(
          `**${file.path}** - Large AND frequently changing. This is a complexity hotspot that's evolving rapidly.`
        );
      }
    }

    // Files changing a lot but no one knows why
    for (const file of highChurn.slice(0, 2)) {
      if (!largeFileNames.includes(file.path)) {
        scary.push(
          `**${file.path}** - Changed ${file.changes} times recently. Why does this file need so many changes?`
        );
      }
    }
  }

  // High severity risks
  const criticalRisks = analysis.risks.filter((r) => r.severity === "high");
  for (const risk of criticalRisks.slice(0, 2)) {
    if (risk.file) {
      scary.push(`**${risk.file}** - ${risk.description}`);
    }
  }

  return scary;
}
